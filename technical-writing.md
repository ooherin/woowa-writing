# 프론트엔드에서 웹 접근성을 높이는 방법

## 예상 독자

- 웹 접근성에 흥미가 있거나 알고 싶은 분
- 웹 접근성을 지키는 방법을 알고 자신의 서비스에 적용하고 싶은 프론트엔드 개발자

## 서론

웹 접근성은 장애를 가진 사람들을 포함한 모든 사용자가 웹사이트나 애플리케이션을 쉽게 이용할 수 있도록 보장하는 것을 목표로 합니다. 이는 단순히 디자인의 개선이나 기술적 기능의 추가를 의미하는 것이 아니라, 모두가 동등하게 서비스에 접근할 수 있는 환경을 조성하는 것을 뜻합니다.

예를 들어, 일반적인 사용자가 유튜브에서 영상을 찾아 보는 과정을 생각해 봅시다. 애플리케이션 내에서 버튼을 클릭하고, 리스트에서 원하는 항목을 선택하고, 검색 창에 텍스트를 입력해 결과를 확인할 수 있습니다. 원하는 영상도 쉽게 보고 클릭할 수도 있습니다.

하지만 시력이 낮거나 특정 색을 인지하지 못하는 사용자, 손의 움직임에 제약이 있는 사용자에게는 어떨까요? 이러한 ‘보는 행위'에 기반한 모든 상호작용 방식이 큰 제약이 될 수 있습니다. 보는 것 말고도 기본적인 상호작용 방식이라고 생각하는 모든 요소들이 누군가에게는 제약이 됩니다.

- 텍스트, 버튼 등 시각적인 모든 요소 - 시력이 안 좋은 사람에게 제약
- 대비가 거의 없는 색으로 이루어진 요소 - 적록색맹 등 색을 잘 구별하지 못하는 사람에게 제약
- 섬세한 마우스나 키보드 작업을 해야 하는 요소 - 손 운동이 어려운 사람에게 제약

이들은 일반적인 상황과는 다른 제약상황에 처해 있는 사용자들입니다. 이들도 무리없이 웹 페이지를 사용할 수 있게 하는 것이 웹 접근성의 목표입니다.

서비스를 만들 때 웹 접근성을 고려하는 행위는 오직 장애가 있는 사람들만을 위한 것이 아닙니다. 놀랍게도, 장애가 없는 사람들도 혜택을 누릴 수 있습니다.

예를 들어, 우리가 검색이나 입력을 할 때 편리하게 쓰는 자동완성 기능은 원래 장애를 가진 사용자들을 위한 기능이였습니다. 특히, 시각 장애나 손이 불편한 사람들에게 유용하도록 만들어졌습니다. 이런 사람들은 전반적으로 타이핑이 어렵거나, 시간이 오래 걸리는 문제를 가지고 있었습니다. 하지만, 현재 자동완성 기능은 장애가 없는 사람도 빠르고 쉽게 타이핑을 하기 위해 자동완성 기능을 사용합니다. 이들도 특정 상황에서 이 기능의 편리함을 느끼기 때문입니다.

<img src="https://github.com/user-attachments/assets/c65a7933-0854-4973-8db7-bd28e3fb8c87"/>

결론적으로, 장애가 있는 사용자를 고려하는 행위는, 곧 장애가 없는 사용자 또한 고려하는 행위라고 할 수 있습니다.

또한, 우리나라의 <a href="http://www.kwacc.or.kr/Accessibility/Law" target="_blank">「장애인차별금지 및 권리구제 등에 관한 법률」</a>에서는 장애가 있는 사람도 비장애인과 동등하게 웹사이트를 이용할 수 있도록 웹 접근성을 준수할 것을 명시하고 있습니다. 법률에 따르면, 웹사이트와 애플리케이션의 설계 및 개발 시 접근성을 고려하지 않으면 차별 행위로 간주될 수 있으며, 이는 법적 책임으로 이어질 수 있습니다.

이제 프론트엔드 개발자로서 이 접근성을 어떻게 하면 높일 수 있을지 알아보도록 하겠습니다.

## 1. 웹 접근성을 높이는 기본적인 방법

기본적으로 웹 접근성 자체를 올리는 방법을 먼저 소개하겠습니다.

### (1) 언어 및 제목 설정

스크린 리더기는 낭독기이기 때문에, 언어의 영향을 받습니다. `index.html` 파일에 `lang` 을 `ko`로 설정하면 스크린 리더기의 언어를 한국어로 설정할 수 있습니다. 이는 접근성 뿐만 아니라 `SEO(검색 엔진 최적화)`에도 도움이 되니 잘 설정하는 것이 좋습니다. 그리고 `title` 에 해당 문서에 대한 제목을 설정해주세요. 스크린 리더기가 처음 웹을 탐색할 때 이 제목을 읽어줍니다. 사용자는 이 제목을 듣고 어떤 웹 페이지에 들어왔는지를 쉽게 알 수 있습니다.

### (2) 시맨틱 태그 사용

접근성을 높이는 많은 방법들이 있지만, 시맨틱 태그를 활용하는 것은 가장 기본적이자 필수적인 방법입니다. 올바른 태그를 사용하는 것은 내용의 가독성을 높여줄 뿐만 아니라, 사용자가 탐색을 쉽게 해줍니다. 또한 `SEO(검색 엔진 최적화)` 에도 효과적입니다. 구글, 네이버 같은 검색 엔진은 시맨틱 태그를 기반으로 페이지의 내용을 분석하고, 페이지 내의 키워드들의 우선순위를 파악하기 때문입니다. 즉, 올바른 시맨틱 태그를 사용하는 것은 많은 장점을 가지고 있기에 접근성을 높이는 방법들 중에서 1순위로 기억해두어야 합니다.

우선, 시맨틱 태그를 선택하는 기준은 콘텐츠의 의미와 기능입니다. 그 콘텐츠가 어떤 역할을 하는지, 어떤 내용을 담고 있는지에 따라서 시맨틱 태그가 결정된다는 것입니다. 예를 들어, 페이지의 주요 콘텐츠나 본문은 `<main>` 으로 감싸야 합니다.

사실 위 내용을 모르는 사람은 많지 않습니다. 시맨틱 태그는 html 의 필수 요소이니까요. 중요한 것은, `section`, `nav`, `article` 등 자주 사용하는 시맨틱 태그들을 잘 익혀두고 필요할 때 사용하는 것입니다. div 를 남발하기보다 시맨틱 태그로 접근성을 효과적으로 챙기면 어떨까요?

### (3) `<h1>` - `<h6>` 구획 제목 요소

`<h1>`-`<h6>`로 이루어진 HTML 구획 제목 요소를 사용하는 것도 중요합니다. 이 태그들은 아시다시피 문서의 구문을 계층화시키는 시맨틱 태그의 일종입니다.

이 중에서 `<h1>` 태그의 중요성에 대해 얘기해보려고 합니다. `<h1>` 태그는 제목을 의미합니다. 그래서 제목 태그라고 불리기도 합니다. 책의 제목은 딱 하나만 존재하는 것 처럼, 웹 페이지의 `<h1>` 도 페이지 당 딱 하나만 존재해야 합니다. 또한, `<h1>` 꼭 사용하는 것이 좋습니다. 시맨틱 태그랑 비슷한 이유인데, 구글 같은 SEO 가 이 `<h1>` 제목 태그를 가장 우선시하기 때문입니다. 또한 `<h1>` 태그는 디스플레이랑 검색 기능에서 사용자가 콘텐츠를 탐색하는데 도움을 줍니다. 마치 저희가 책을 고를 때 본문 보다 제목을 보고 고르는 것과 비슷합니다. 스크린 리더기를 사용하는 사용자가 웹 페이지를 탐색하면, 스크린 리더기가 `<h1>` 태그를 가장 먼저 읽어줍니다.

구획 요소에서 사람들이 많이 실 수 할 수 있는 것이, 구획 요소의 순서를 바로 건너 뛰는 실수입니다. `<h1>` 태그의 다음 요소에 구획 제목 요소를 사용하고 싶다면 `<h3>` 이 아닌 `<h2>` 를 써야만 합니다. 만약 스타일 때문에 이렇게 태그를 뛰어 넘었다면 이는 잘 못 사용한 것입니다. `<h1>`-`<h6>` 은 스타일만을 위한 태그가 아닌, 그 이상의 구문적 의미를 가지고 있음을 알고 써야 합니다. 이런 식으로 접근성을 높이는 일 뿐만 아니라, 접근성을 해치는 안 좋은 패턴을 숙지하고 이를 피하는 것도 중요합니다.

## 2. 스크린 리더 접근성을 높이는 방법

스크린 리더 접근성은 스크린 리더를 사용하기 편리하게 만드는 것을 의미합니다. 스크린 리더는 스크린의 정보를 음성으로 출력해 주는 화면 낭독 프로그램입니다. 저시력 시각장애인과 난독증을 가진 사람들은 쉽게 글씨를 읽을 수 없기 때문에 이 스크린 리더를 사용하여 웹을 사용합니다. 스크린 리더는 화면에 출력된 텍스트, 이미지, 버튼 등을 음성으로 변환해줍니다. 사용자는 이 음성을 듣고, 현재 페이지에 어떤 요소들이 있는지 알 수 있습니다.

### ARIA

ARIA 는 `Accessible Rich Internet Applications` 의 약자로, 장애를 가진 사용자가 웹 사이트를 쉽게 접근할 수 있도록 돕는 여러 속성들을 말합니다. ARIA는 HTML 에서 표현할 수 없는 접근성을 표현하여 HTML 을 보충해줍니다. 하지만, 태그보다 ARIA 가 주가 된다면 접근성 안티패턴을 만들 수도 있습니다.

우선 ARIA 에 대해 설명드리겠습니다. ARIA는 역할(role), 속성(property), 상태(state) 로 이루어져 있습니다.

### (1) 역할 (role)

`role` 속성은 HTML 이 어떤 역할을 하는지 정의합니다. 이 속성은 스크린 리더가 해당 요소가 특정 역할 요소(버튼, 체크박스, 검색) 으로 인식하게 합니다. 보통 이 속성은 태그로 표현할 수 없는 상황에서 사용합니다.

예를 들어, 밑 예제에서는 form 태그를 사용하여 상품 검색 바를 구현했습니다. 하지만 스크린 리더 사용자는 이 form 태그가 어떤 역할을 하는 form 인지 알 수 없습니다. form 은 검색 기능을 만들 때도 쓰이지만, 어떤 내용을 채워서 제출하는 제출 폼으로도 쓰이니까요. 이 경우, `role=”search”` 를 추가해 사용자에게 힌트를 줄 수 있습니다. 스크린 리더는 `role=”search”` 가 적용된 요소에 포커스가 가면, “검색" 이라고 사용자가에게 알려줍니다. 이걸 듣는 사용자는 쉽게 그 요소의 기능을 파악할 수 있습니다.

```jsx
/* role 속성을 사용 */
<form role="search">
  <label htmlFor="search-input">Search:</label>
  <input type="text" id="search-input" name="search" placeholder="상품 검색" />
  <button type="submit">검색</button>
</form>
```

이 search 외에도 `dialog`(모달 대화 상자), `banner`(페이지의 주요 헤더), `alert`(사용자에게 중요한 정보를 알릴 때 사용. 스크린 리더는 즉시 읽어줌.), `button`, `checkbox` 등 다양한 역할이 있습니다. 하지만 이 role 의 기능이 너무 다양해서 잘 못 사용하는 경우가 많기도 한데, 이는 밑에서 설명드리겠습니다.

### (2) 속성 (Properties)

두번째 ARIA의 구조는 속성입니다. 상황에 따라 role 보다 스크린 리더에 많은 내용을 전달할 수 있는 기능입니다. 속성은 3번째 요소인 상태(state)와 비슷해보일 수 있는데, 서비스 내에서 자주 변경되는 것은 상태(state), 그렇지 않은 것은 속성이라고 알아두시면 됩니다. 이제 자주 사용되고 유용한 aria 속성에 대해 설명드리겠습니다.

#### aria-label

`aria-label` 은 요소의 이름이라고 할 수 있습니다. 요소 안에 text 만으로 설명이 충분하지 않을 때 이 `aria-label` 을 사용하면 좋습니다. 예를 들어, 항공사 페이지를 만드는 도중 다음과 같은 컴포넌트가 있다고 생각해볼까요?

<img width="333" alt="스크린샷 2024-10-29 오후 2 19 11" src="https://github.com/user-attachments/assets/f56bd1b4-d55d-40ad-9b44-6ee00ae4ce86">

위의 파란색 박스의 컴포넌트는 다음과 같이 구현된 상태입니다.

```jsx
<label>성인</label>
<button
  className="button-text"
  onClick={incrementCount}
  type="button"
>
  <img src={plus} alt="증가 아이콘" />
</button>
```

딱 보기에는 아무 문제가 없어 보이고 시각 장애인들도 쉽게 이해할 수 있을 거라는 생각이 들지도 모릅니다. 하지만 시각장애인들은 버튼이 '성인 인원을 바꾸는 버튼' 이라는 사실을 인지하기가 힘듭니다. 왜 그럴까요?

시각장애인들은 UI 를 같이 연결해 알 수 있는 정보를 인식할 수 없기 때문입니다. 즉, 버튼 바로 옆에 성인이라는 라벨이 있더라도, UI 를 볼 수 없기 때문에 라벨과 버튼과의 연관성을 알기가 쉽지 않은 것입니다. 이 경우에는, 저희가 직접 이 버튼이 어떤 역할을 하는지에 대해 `aria-label` 을 사용해서 알려주어야 합니다. 밑처럼 aria-label=”성인 승객 증가” 를 추가한다면, 사용자가 버튼을 포커스 했을 때 스크린 리더가 이 버튼이 ”성인 승객 증가” 버튼이라고 읽어줄 것 입니다.

```jsx
/*사용자는 이 라벨과 버튼이 연결되어 있다는 것을 알기가 쉽지 않습니다.*/
<label>성인</label>
<button
  aria-label='성인 승객 증가'
  className="button-text"
  onClick={incrementCount}
  type="button"
>
  <img src={plus} alt="증가 아이콘" />
</button>
```

이와 관련해서 접근성을 높일 수 있는 또 다른 기능을 소개하겠습니다. 바로 스크린 리더 전용 메세지입니다. 생소할 수도 있지만, 위의 aria-label 과 비슷한 기능입니다.

#### 스크린 리더 전용 메세지

만약 사용자가 밑의 버튼을 클릭하면, 자신이 선택한 성인 승객이 몇 명이 되었는지 알 수 있을까요? 아마 쉽지 않을 것입니다. 저희가 제공한 승객 숫자 기능은 오직 시각적인 UI 로만 알 수 있습니다. 이를 보지 못하는 사용자는, 현재 성인 승객이 몇 명 선택되었는지 인지하기가 힘듦니다.

```jsx
<div>현재 선택된 성인 승객 수</div>;
/* 시각 장애인에게는 이 숫자가 보이지 않습니다. */
<span aria-live="polite">{adultCount}</span>;
```

이 경우 가장 쉬운 방법은 UI 를 볼 수 없는 사용자만을 위한 상태 메세지를 만들어 주는 것입니다. 스크린 리더는 렌더링된 태그의 내용을 읽을 수 있기 때문에 접근성이 향상 될 것입니다. 하지만 태그를 사용하면 기존의 UI 를 해칠 수도 있습니다. 이럴 때 쓰는 것이 `visually-hidden` 기능입니다.
`visually-hidden` 은 `display: none` , `visibility: hidden` 처럼 보이지는 않지만 렌더링 트리에 포함시킴으로써 스크린 리더가 해당 메세지를 읽을 수 있습니다.

`visually-hidden` 클래스를 css 로 정의하고, 원하는 태그에 해당 클래스를 적용하면 됩니다. `visually-hidden`은 검색을 통해, 쉽게 css 코드를 확인할 수 있으므로 여기에는 따로 넣지 않았습니다.

만약 승객이 3명이 되었을 때 최대 승객 수에 도달했다는 스크린 리더 전용 메세지를 만들어 주고 싶다면 다음과 같이 하면 됩니다. state 로 메시지를 정의하고, 해당 메시지를 태그로 감싼 후 `visually-hidden` 클래스를 준다면, 해당 요소는 보이지 않지만 스크린 리더는 메시지를 잘 읽어줄 것입니다.

```jsx
const [statusMessage, setStatusMessage] = useState("");
const incrementCount = () => {
  if (adultCount === MAX_PASSENGERS) {
    /*최대 승객수에 도달하면, 스크린 리더가 다음 메세지를 읽습니다.*/
    setStatusMessage("최대 승객 수에 도달했습니다");
    return;
  }
  setStatusMessage("");
};

return (
  statusMessage && (
    <div className="visually-hidden" role="alert">
      {statusMessage}
    </div>
  )
);
```

다시 aria-label 로 돌아가서, aria 의 속성중 다른 요소의 이름을 불러올 수도 있는 기능도 있습니다. `aria-labelledby` 를 사용하면 해당 id 값을 가진 요소의 내용을 스크린 리더가 읽어줍니다. `aria-describedby` 도 `aria-labelledby` 와 비슷한 속성으로 해당 id 값을 가진 요소의 내용을 참조합니다. 둘의 가장 큰 차이는 스크린 리더의 우선 순위로, `aria-labelledby`, `aria-describedby` 순서로 읽게 됩니다.

```jsx
<label id="username-label">사용자 이름</label>
<input
  id="username"
  aria-labelledby="username-label"
  aria-describedby="username-alert"
/>
<div id="username-alert">이름에는 최소 2글자 이상 입력해야 합니다.</div>
```

마지막으로 `aria-hidden` 이라는 속성도 있습니다. 이는 해당 요소의 스크린 리더 텍스트를 끄는 역할을 합니다. 스크린 리더는 모든 텍스트를 읽기 때문에, 해당 내용이 이미 많이 언급되었다면, 이 속성을 사용해 스크린 리더가 해당 내용을 무시하도록 할 수 있습니다.

### (3) 상태 (status)

`aria-live` 와 같은 상태(State) 속성은 스크린 리더 등가 UI의 상태 변화를 감지하고 사용자에게 올바르게 전달할 수 있도록 도와줍니다. javascript 에 의해 웹 페이지는 상태 변화가 많이 일어나는데, 시각 장애인은 UI 를 볼 수 없기 때문에 이 변화를 인지하기가 힘듦니다. 따라서 이를 알려주기 위해 aria-live 을 제공합니다.

#### aria-live

aria-live는 `off`, `polite`, `assertive` 로 3가지의 상태가 있습니다. 기본적으로 `off` 상태입니다. 이는 요소의 컨텐츠가 바뀌더라도 스크린 리더는 이를 사용자에게 읽어주지 않는 상태입니다. `polite`, `assertive` 는 콘텐츠가 변경되었을 때 읽어주는 속성들입니다. 하지만 이 둘의 차이는 해당 메시지의 우선순위입니다. `polite` 는 상태가 변경되어도, 스크린 리더가 진행 중인 내용을 막지 않습니다. 내용이 다 끝난다음에 해당 상태를 알려줍니다. 반면, `assertive` 는 해당 내용이 중요하다고 판단하여, 스크린 리더의 진행 작업을 중단하고 해당 메시지를 읽습니다.

보통 `polite` 속성을 많이 쓰며, 에러 메시지와 같은 긴급한 내용일 경우에만 `assertive` 를 제한적으로 사용합니다. `assertive` 의 경우 스크린 리더의 작업 우선순위를 변경하므로, 작업 중인 사용자에게 혼란을 줄 위험이 있습니다. 따라서 `assertive` 는 필요한 곳에서만 제한적으로 사용해야 합니다.

이 `aria-live` 를 쓸 때는, 해당 속성을 남발하면 스크린 리더가 내용을 중복해서 읽을 수 있고, 이는 오히려 사용자에게 불편함을 줄 수 있습니다. 따라서 `aria-live` 를 쓰기 전에, 이 내용이 정말 사용자에게 필요한 내용인지 생각하고 사용해야 합니다.

#### ARIA 를 사용할 때 주의사항

그렇다면 ARIA은 무조건 쓰면 좋은 기능일까요? 당연히도 아닙니다. ARIA의 기능을 잘 못 사용한다면, 아예 사용하지 않는 편이 더 좋을 수 있습니다. ARIA는 상당수가 HTML 태그로 대체될 수 있습니다. 개발자들이 ARIA 를 사용할 때 쉽게 실수하는 예제를 보여드리면서 설명드리도록 하겠습니다.

#### (1) 시맨틱 태그로 대체할 수 있는 경우

```jsx
/* X */
<button onClick={handleClick}>버튼1</button>;

/* O */
<div role="button" onClick={handleClick}>
  버튼2
</div>;
```

버튼1은 `<button>` 태그를 써서 만든 버튼이고, 버튼2는 `<div>` 태그에 button 이라는 role 을 주어 만든 버튼입니다. 겉보기에는 둘다 `onClick` 이라는 이벤트를 가져 영락없는 버튼처럼 보이나, 조금의 차이가 있습니다. `<button>` 태그의 경우 space, return, enter 키를 사용해 버튼을 클릭하는 기능이 내장되어 있습니다. 따라서 첫번째 버튼은, 키보드로 버튼에 접근하거나 enter로 버튼을 클릭할 수 있습니다.

하지만 두번째 버튼은 역할만 button 으로 지정해 놨을 뿐, 버튼 태그의 모든 기능을 사용할 수 없습니다. button 같이 키보드로 버튼에 접근할 수 있게 하려면 `tabIndex` 속성을 따로 지정하거나, keydown 이벤트를 직접 지정하는 등의 추가 작업이 필요합니다.

한가지 알아두셔야 할 점은, ARIA 태그를 지원하는 환경은 시맨틱 태그보다 적다는 점입니다. 즉, role은 해당 요소에 어울리는 시맨틱 태그를 먼저 알아보고 사용한 후, 적용할 시맨틱 태그가 없거나 마땅치 않을 때만 부가적으로만 사용하는 것이 좋습니다.

#### (2) 속성이 중복되거나 상충되는 경우

```jsx
{/* X 같은 속성을 중복 사용한 경우 */}
<button role="button">...</button>
<fieldset role="group">...</fieldset>
<ul role="list">...</ul>

{/* X 체크박스의 상태가 서로 상충됨 */}
<input type="checkbox" checked aria-checked="false" />
```

위 예제 또한 ARIA 속성을 잘 못 활용하고 있는 예시인데요. 첫번째 예시는, 같은 속성을 중복해서 사용하고 있는 경우입니다. 이미 button 이라는 시맨틱 태그를 사용했는데, role로 button을 지정하는 것은 의미가 없습니다. 이는 오히려 코드의 가독성을 떨어뜨리고, 스크린 리더를 혼란스럽게 만들 뿐입니다. 많은 시맨틱 태그들은 이미 자기에게 맞는 ARIA 속성을 내재하고 있는 경우가 많습니다. 따라서 ARIA 속성을 사용할 때에는 이미 그 속성이 태그에 존재하지 않는지 확인해야 합니다.

두번째 예제는, 태그의 속성과 ARIA 의 속성이 상충되는 경우입니다. 첫 렌더링 때 `checked` 는 true이지만, `aria-checked` 에서는 false 속성을 가지고 있죠. 이렇게 되면 같은 `checked` 속성이 서로 상충됩니다. 굳이 `aria-checked` 를 쓸 필요가 없이 checked 라고만 지정해도, 스크린 리더는 이 체크박스의 체크 상태를 잘 읽어줍니다.

추가한 ARIA 속성이 기존의 태그나, 상태와 상충되지 않는지도 확인해보면 좋습니다. 이 외에도 ARIA 를 사용할 때 주의해야 할 내용이 이 문서에 소개되어 있습니다. 관심이 있다면 참고해도 좋을 것 같습니다.

### 모달 접근성 - 스크린 리더로 모달과 본문의 내용을 분리하기

모달은 접근성을 해치기 쉬운 요소입니다. 왜냐하면 시각 장애인의 경우 모달이 열린 것 조차 인지하기 어렵기 때문입니다. 따라서 모달은 더 세심한 작업이 필요합니다.

모달이 열렸을 때, 가장 먼저 해야 할 것은 스크린 리더 사용자를 위해 모달이 열렸다는 것을 인식시켜주는 것입니다. 이는 앞서 설명드린 스크린 리더 전용 메시지를 사용해 사용자에게 쉽게 알릴 수 있습니다. 그 다음 해야 할 일은 모달과 뒤에 원래 있던 본문 페이지를 분리하는 것입니다. 아무리 모달이 열렸다고 해도, 스크린 리더는 본문에 있는 내용을 차례차례 읽게 됩니다. 하지만 모달이 열린 상태에서 사용자가 뒤에 내용을 듣는다면 혼란스러울 수 있습니다. 따라서 모달이 열렸을 때는 본문의 내용을 스크린 리더가 읽지 않게 하는 것이 중요합니다.

```jsx
useEffect(() => {
  const appElement = document.getElementById("app");
  if (isModalOpen && appElement) {
    appElement.setAttribute("aria-hidden", "true");
  } else {
    appElement?.removeAttribute("aria-hidden");
  }
}, [isModalOpen]);
```

위 코드는 모달이 열리는 페이지에 추가한 코드입니다. 페이지가 렌더링 되고 모달이 열린 상태가 되면 나머지 본문 요소들에 `aria-hidden` 속성을 추가하여, 의도적으로 스크린 리더가 해당 내용들을 전달하지 못하도록 하는 것입니다. 이렇게 되면 모달 안에 있는 내용만 사용자가 집중할 수 있습니다.

## 3. 키보드 접근성을 높이는 방법

이제 키보드 접근성을 높이는 방법에 대해 설명 드리겠습니다. 키보드 접근성은 모든 사용자가 키보드만으로 웹 페이지와 상호작용할 수 있게 만드는 것입니다. 시각 장애인, 운동 장애인, 또는 키보드를 선호하는 사용자 등 다양한 사용자들이 마우스 없이 키보드만으로 웹사이트의 콘텐츠를 탐색하고 상호작용할 수 있으면 됩니다.

### (1) tabIndex

키보드에서 요소의 포커스를 옮길 때 어떤 키를 쓸까요? 바로 탭 입니다. `tabIndex`를 사용하면, 개발자의 의도대로 사용자의 탭에 따른 포커스를 조정할 수 있습니다. `tabIndex` 가 -1 일 경우에는, 요소가 포커스 되지 않습니다. `tabIndex` 가 0이면 기본적인 HTML 의 순서에 따라 요소가 포커스됩니다. `tabIndex` 가 1 이상이 되면 사용자가 순서대로 순서를 지정할 수 있습니다. 작은 숫자부터 큰 숫자대로 이동하게 됩니다. 하지만, 이렇게 `tabIndex` 를 양수로 지정하는 것은, 스크린 리더의 의도적인 순서를 변경하는 것이므로 부작용이 생길 수 있어 주의가 필요합니다.

```jsx
<button tabindex="1">첫 번째로 읽음</button>
<button tabindex="2">두 번째로 읽음</button>
<button tabindex="0">세 번째로 읽음(HTML 기본 순서)</button>
<button tabindex="-1">읽지 않음</button>
```

### (2) 본문 바로가기 기능

본문 바로가기 기능은 키보드 접근성을 높이는 좋은 방법입니다. 키보드 사용자는 상위에 링크부터 하나하나씩 이동하기 때문에, 원하는 본문 기능 까지 포커스를 하는 것이 오래 걸리기 때문입니다. 따라서 웹 사이트에 들어왔을 때, 바로 본문 위치까지 옮겨주는 본문 바로가기 링크를 걸어두면 좋습니다.

본문 바로가기는 가장 상단에 다음과 같이 만들어주면 됩니다. 바로 이동시키고 싶은 본문은 a 태그에 링크로 달아놓은 #content 에서 content 를 id 로 지정하면 됩니다.

```jsx
<a href="#content" className={styles.skipTo}>
  본문 바로가기
</a>

//본문 바로가기를 선택하면 이 콘텐츠로 이동합니다.
<main id="content">
  //메인 콘텐츠
</main>

//css
.skipTo {
  position: absolute;
  top: -99px;
  left: 0;
  width: 100%;
  padding: 10px 0;
  text-align: center;
  text-decoration: none;
  z-index: 999;
}

.skipTo:hover,
.skipTo:focus,
.skipTo:active {
  top: 0;
}
```

해당 기능을 만들어주면, 사용자는 사이트에 처음 접근했을 때 탭을 누르면 숨겨져 있던 본문 바로가기 버튼이 나오게 되고, 이 링크를 선택하면 본문으로 이동하게 됩니다. 따라서 사용자는 복잡한 nav 바를 탐색하지 않아도 쉽게 본문으로 이동하여 탐색을 할 수 있습니다.

### (3) 모달 접근성 - 포커스 트랩으로 포커스를 모달 내부에서만 돌게 만들기

모달이 열렸을 때 포커스는 기본적으로 모달의 내용이 아닌, 뒤에 본문 내용을 가리키게 됩니다. 사용자는 모달의 내용을 조작하고 싶은데 포커스가 모달 뒤의 내용에 있다면 곤란하겠죠. 이럴 때는 포커스 트랩을 만들어 사용할 수 있습니다. 포커스 트랩은 모달 안에서만 포커스가 이동하도록 만드는 것을 말합니다. 포커스 트랩의 경우 만드는 것이 조금 까다로울 수 있지만, 서비스에 모달이 있다면 한번 만들어 적용해 보는것을 추천합니다.

## 결론

이렇게 프론트엔드에서 접근성을 높이는 법을 알아봤습니다. 웹 접근성을 고려하면 당신의 서비스는 더 다양한 사용자에게 더욱 유익하고 멋진 경험을 제공할 수 있습니다. 결과적으로 어느 상황에서나, 어떤 장애가 있거나, 모든 사용자들이 ‘서비스를 만족하며 사용하는 경험’ 이라는 목적지에 도달할 수 있을 것입니다.
